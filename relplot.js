class MAMathContext {
  // Properties:
  // - thetaFn (function generated by MAIntervalMath.thetaFunc(i))
  // - rFn (function, one of MAIntervalMath.rFunc, MAIntervalMath.negRFunc)
  constructor() {
    this.thetaFn = MAIntervalMath.thetaFunc(0, 0)
    this.rFn = MAIntervalMath.rFunc
  }
}

class MAPoint {
  // Properties:
  // - x (float, x coordinate)
  // - y (float, y coordinate)
  constructor(x, y) {
    this.x = x
    this.y = y
  }

  isNear(other) {
    return MAFloatMath.floatNear(this.x, other.x) && MAFloatMath.floatNear(this.y, other.y)
  }

  isEqual(other) {
    return MAFloatMath.floatEquals(this.x, other.x) && MAFloatMath.floatEquals(this.y, other.y)
  }

  distanceTo(other) {
    return Math.sqrt((this.x-other.x)**2 + (this.y-other.y)**2)
  }
}

class MALineSegment {
  // Properties:
  // - p1 (MAPoint)
  // - p2 (MAPoint)
  constructor(p1, p2) {
    this.p1 = p1
    this.p2 = p2
  }

  midpoint() {
    return new MAPoint((this.p1.x+this.p2.x)/2, (this.p1.y+this.p2.y)/2)
  }

  // Use this to perform checks of whether a rendered line segment
  // visually contains a point.
  // On its own, the containsPoint method is too precise and will return
  // false for points that visually rest on a curve
  visuallyContainsPoint(p, resolution) {
    // This closeEnough factor was chosen while tuning the unit test
    // for pow(x,y)=pow(y,x). I visually inspected that (0,0) looks included in
    // the graph and adjusted this factor so the point would pass this check.
    let closeEnough = resolution/1.4

    // containsPoint is a better check when the line segment is long
    if (this.containsPoint(p, closeEnough)) {
      return true
    }

    // These distance checks are better when the segment is short or
    // p is barely beyond one of the endpoints

    let dist1 = this.p1.distanceTo(p)
    let dist2 = this.p2.distanceTo(p)
    let distMid = this.midpoint().distanceTo(p)

    //if (p.x == 0.5 && p.y == 0.25 && (dist1+dist2+distMid < 0.3)) {
    //  console.log(`vCP closeEnough ${closeEnough} dist1 ${dist1} dist2 ${dist2} distMid ${distMid} ${this.toString()}`)
    //}

    if ((dist1 < closeEnough) || (dist2 < closeEnough) || (distMid < closeEnough)) {
      return true
    }

    return false
  }

  containsPoint(p, optionalEps) {
    // This uses a more permissive check than floatEquals and floatNear.
    // For MALineSegment instances produced by MAReplot.render, the precision
    // depends on the resolution that's passed in. This more permissive epsilon value
    // is needed to validate render output with the default resolution.
    const nearEps = optionalEps ? optionalEps : 1e-6

    // Compare the slopes of line segments:
    // this.p1 to p:       (p.y-this.p1.y) / (p.x-this.p1.x)
    // this.p1 to this.p2: (this.p2.y-this.p1.y) / (this.p2.x-this.p1.x)
    // Refactor to avoid division to minimize impact of float precision
    let slopeHalfA = (p.y-this.p1.y) * (this.p2.x-this.p1.x)
    let slopeHalfB = (this.p2.y-this.p1.y) * (p.x-this.p1.x)
    let d = Math.abs(slopeHalfA-slopeHalfB)

    let slopesMatch = (d < nearEps)

    let isBetweenX = p.x >= Math.min(this.p1.x, this.p2.x)-nearEps && p.x <= Math.max(this.p1.x, this.p2.x)+nearEps
    let isBetweenY = p.y >= Math.min(this.p1.y, this.p2.y)-nearEps && p.y <= Math.max(this.p1.y, this.p2.y)+nearEps

    //if (isBetweenX && isBetweenY) {
    //  console.log(`containsPoint: p=(${p.x}, ${p.y})  ${this.toString()}  slopeHalfA=${slopeHalfA}  slopeHalfB=${slopeHalfB}  slopeDiff=${d} nearEps=${nearEps}  slopesMatch=${slopesMatch}`)
    //}

    return slopesMatch && isBetweenX && isBetweenY
  }

  combineWith(otherLine) {
    let oL = otherLine

    if (oL.p1.x == this.p1.x && oL.p1.y == this.p1.y &&
        oL.p2.x == this.p2.x && oL.p2.y == this.p2.y) {
      // oL is the same as this
      return true
    } else if (oL.p2.x == this.p1.x && oL.p2.y == this.p1.y &&
               oL.p1.x == this.p2.x && oL.p1.y == this.p2.y) {
      // oL (with p1 and p2 flipped) is the same as this
      return true
    } else if (oL.p1.x == this.p1.x && oL.p1.y == this.p1.y) {
      // oL.p1 == this.p1 then check whether oL.p2-this.p2 contains this.p1
      let testLine = new MALineSegment(oL.p2, this.p2)
      if (testLine.containsPoint(this.p1)) {
        this.p1 = oL.p2
        return true
      }
    } else if (oL.p1.x == this.p2.x && oL.p1.y == this.p2.y) {
      // oL.p1 == this.p2 then check whether oL.p2-this.p1 contains this.p2
      let testLine = new MALineSegment(oL.p2, this.p1)
      if (testLine.containsPoint(this.p2)) {
        this.p2 = oL.p2
        return true
      }
    } else if (oL.p2.x == this.p1.x && oL.p2.y == this.p1.y) {
      // oL.p2 == this.p1 then check whether oL.p1-this.p2 contains this.p1
      let testLine = new MALineSegment(oL.p1, this.p2)
      if (testLine.containsPoint(this.p1)) {
        this.p1 = oL.p1
        return true
      }
    } else if (oL.p2.x == this.p2.x && oL.p2.y == this.p2.y) {
      // oL.p2 == this.p2 then check whether oL.p1-this.p1 contains this.p2
      let testLine = new MALineSegment(oL.p1, this.p1)
      if (testLine.containsPoint(this.p2)) {
        this.p2 = oL.p1
        return true
      }
    }

    return false
  }

  toString() {
    return `[MALineSegment (${this.p1.x}, ${this.p1.y}) (${this.p2.x}, ${this.p2.y})]`
  }
}

class MABox {
  // Represents a rectangle as defined by two opposite corners
  // Properties:
  // - p1 (MAPoint)
  // - p2 (MAPoint)
  constructor(p1, p2) {
    this.p1 = p1
    this.p2 = p2
  }

  upperLeftCorner() {
    let minX = Math.min(this.p1.x, this.p2.x)
    let maxY = Math.max(this.p1.y, this.p2.y)
    return new MAPoint(minX, maxY)
  }

  bottomRightCorner() {
    let maxX = Math.max(this.p1.x, this.p2.x)
    let minY = Math.min(this.p1.y, this.p2.y)
    return new MAPoint(maxX, minY)
  }

  visuallyContainsPoint(p, resolution) {
    // This closeEnough factor was chosen while tuning the unit test
    // for x^2+y^2<1. I visually inspected that (0,1) looks included in
    // the graph and adjusted this factor so the point would pass this check.
    let closeEnough = resolution/1.9
    return this.containsPoint(p, closeEnough)
  }

  containsPoint(p, optionalEps) {
    const nearEps = optionalEps ? optionalEps : 1e-6

    let upperLeft = this.upperLeftCorner()
    let bottomRight = this.bottomRightCorner()

    let xWithin = p.x >= upperLeft.x-nearEps && p.x <= bottomRight.x+nearEps
    let yWithin = p.y >= bottomRight.y-nearEps && p.y <= upperLeft.y+nearEps

    return xWithin && yWithin
  }

  toString() {
    return `[MABox (${Math.min(this.p1.x, this.p2.x)}, ${Math.min(this.p1.y, this.p2.y)}) (${Math.max(this.p1.x, this.p2.x)}, ${Math.max(this.p1.y, this.p2.y)})]`
  }
}

class MAInterval {
  // lb - number, lower bound
  // ub - number, upper bound
  // Requirement: lb <= ub
  constructor(lb, ub) {
    this.lb = lb
    this.ub = ub
    this.isEmpty = false
  }

  isEqual(other) {
    let bothEmpty = (other != null) && this.isEmpty && other.isEmpty
    return (other != null) && (bothEmpty || (this.lb === other.lb && this.ub === other.ub && this.isEmpty === other.isEmpty))
  }

  static empty() {
    let r = new MAInterval(Number.NaN, Number.NaN)
    r.isEmpty = true
    return r
  }
}

const MAFloatMath = {
  // Copied from relplot's interval.sml
  // I don't understand why containsZero compares directly to 0 when this
  // uses an epsilon
  // Note: equivalent in interval.sml is "close"
  floatEquals: function(f1, f2) {
    const eps = 1e-7
    let d = Math.abs(f2-f1)

    // f1 == f2 clause is for POSITIVE_INFINITY, NEGATIVE_INFINITY comparisons
    return f1 == f2 || (d < eps) || (d < eps*(Math.abs(f1) + eps))
  },

  // Copied from relplot's interval.sml
  // Note: equivalent in interval.sml is "near"
  floatNear: function(f1, f2) {
    const nearEps = 1e-6
    let d = Math.abs(f2-f1)

    return this.floatEquals(f1, f2) || (d < nearEps) || (d < nearEps*(Math.abs(f1) + nearEps))
  },
}
Object.freeze(MAFloatMath)

const MAIntervalMath = {
  toInterval: function(a) {
    if (a instanceof MAInterval) {
      return a
    } else if (typeof a === "number") {
      return new MAInterval(a, a)
    } else {
      return null
    }
  },

  // Note: when adding new mathematical functions here, make sure to also add them to the parser
  // in parser/builtin.js. Search in that file for "MAIntervalMath".

  // a - interval or number
  // b - interval or number
  plus: function(a, b) {
    a = this.toInterval(a)
    b = this.toInterval(b)

    if (a.isEmpty || b.isEmpty) {
      return MAInterval.empty()
    }

    let lb = a.lb + b.lb
    let ub = a.ub + b.ub

    lb = isNaN(lb) ? Number.NEGATIVE_INFINITY : lb
    ub = isNaN(ub) ? Number.POSITIVE_INFINITY : ub
    return new MAInterval(lb, ub)
  },


  // a - interval or number
  neg: function(a) {
    a = this.toInterval(a)

    if (a.isEmpty) {
      return MAInterval.empty()
    }

    return new MAInterval(-a.ub, -a.lb)
  },


  // a - interval or number
  sign: function(a) {
    a = this.toInterval(a)

    if (a.isEmpty) {
      return MAInterval.empty()
    }

    return new MAInterval(Math.sign(a.lb), Math.sign(a.ub))
  },


  // a - interval or number
  // b - interval or number
  times: function(a, b) {
    a = this.toInterval(a)
    b = this.toInterval(b)

    if (a.isEmpty || b.isEmpty) {
      return MAInterval.empty()
    }

    if (a.lb >= 0) {
      if (b.lb >= 0) {
        return new MAInterval(a.lb*b.lb, a.ub*b.ub)
      } else if (b.ub <= 0) {
        return new MAInterval(a.ub*b.lb, a.lb*b.ub)
      } else {
        return new MAInterval(a.ub*b.lb, a.ub*b.ub)
      }

    } else if (a.ub < 0) {

      if (b.lb >= 0) {
        return new MAInterval(a.lb*b.ub, a.ub*b.lb)
      } else if (b.ub <= 0) {
        return new MAInterval(a.ub*b.ub, a.lb*b.lb)
      } else {
        return new MAInterval(a.lb*b.ub, a.lb*b.lb)
      }

    } else {

      if (b.lb >= 0) {
        return new MAInterval(a.lb*b.ub, a.ub*b.ub)
      } else if (b.ub <= 0) {
        return new MAInterval(a.ub*b.lb, a.lb*b.lb)
      } else {
        return new MAInterval(Math.min(a.lb*b.ub, a.ub*b.lb), Math.max(a.ub*b.ub, a.lb*b.lb))
      }
    }
  },


  // a - interval or number
  // b - interval or number
  mod: function(a, b) {
    a = this.toInterval(a)
    b = this.toInterval(b)

    if (a.isEmpty || b.isEmpty) {
      return MAInterval.empty()
    }

    // modulo by 0 is undefined
    let threshold = 1e-3
    if (b.ub-b.lb < threshold && Math.abs(b.ub) < threshold) {
      return MAInterval.empty()
    }

    // There are different definitions that give different results when negative numbers are involved:
    // https://en.wikipedia.org/wiki/Modulo_operation

    // This implementation is "floored division"
    let res = this.plus(a, this.neg(this.times(b, this.floor(this.times(a, this.recip(b))))))

    // This implementation is "truncated division"
    //let res = this.plus(a, this.neg(this.times(b, this.trunc(this.times(a, this.recip(b))))))

    return res
  },


  // a - interval or number
  abs: function(a) {
    a = this.toInterval(a)

    if (a.isEmpty) {
      return MAInterval.empty()
    }

    if (a.lb >= 0) {
      return a
    } else if (a.ub <= 0) {
      return new MAInterval(-a.ub, -a.lb)
    } else {
      return new MAInterval(0, Math.max(-a.lb, a.ub))
    }
  },


  // a - interval or number
  trunc: function(a) {
    a = this.toInterval(a)

    if (a.isEmpty) {
      return MAInterval.empty()
    }

    let threshold = 1e-3
    if (a.ub-a.lb < threshold) {
      return new MAInterval(Math.trunc(a.ub), Math.trunc(a.ub))
    }

    return new MAInterval(Math.trunc(a.lb), Math.trunc(a.ub))
  },


  // a - interval or number
  floor: function(a) {
    a = this.toInterval(a)

    if (a.isEmpty) {
      return MAInterval.empty()
    }

    // Handle the discontinuity in the floor function to avoid drawing points that are not valid results
    // The floor function should find no valid results in the exceedingly thin sliver of the number line
    // where its value jumps from one integer to the next.
    // This logic makes the graph of y=floor(x) lack vertical line segments connecting the steps
    let threshold = 1e-3
    if (a.ub-a.lb < threshold) {
      return new MAInterval(Math.floor(a.ub), Math.floor(a.ub))
    }

    return new MAInterval(Math.floor(a.lb), Math.floor(a.ub))
  },


  // a - interval or number
  ceil: function(a) {
    a = this.toInterval(a)

    if (a.isEmpty) {
      return MAInterval.empty()
    }

    // Handle the discontinuity in the ceil function to avoid drawing points that are not valid results
    // The ceil function should find no valid results in the exceedingly thin sliver of the number line
    // where its value jumps from one integer to the next.
    // This logic makes the graph of y=ceil(x) lack vertical line segments connecting the steps
    let threshold = 1e-3
    if (a.ub-a.lb < threshold) {
      return new MAInterval(Math.ceil(a.lb), Math.ceil(a.lb))
    }

    return new MAInterval(Math.ceil(a.lb), Math.ceil(a.ub))
  },


  // a - interval or number
  // b - interval or number
  max: function(a, b) {
    a = this.toInterval(a)
    b = this.toInterval(b)

    if (a.isEmpty || b.isEmpty) {
      return MAInterval.empty()
    }

    return new MAInterval(Math.max(a.lb, b.lb), Math.max(a.ub, b.ub))
  },


  // a - interval or number
  // b - interval or number
  min: function(a, b) {
    a = this.toInterval(a)
    b = this.toInterval(b)

    if (a.isEmpty || b.isEmpty) {
      return MAInterval.empty()
    }

    return new MAInterval(Math.min(a.lb, b.lb), Math.min(a.ub, b.ub))
  },


  // a - interval or number
  exp: function(a) {
    a = this.toInterval(a)

    if (a.isEmpty) {
      return MAInterval.empty()
    }

    return new MAInterval(Math.exp(a.lb), Math.exp(a.ub))
  },


  // a - interval or number
  ln: function(a) {
    a = this.toInterval(a)

    if (a.isEmpty) {
      return MAInterval.empty()
    }

    if (a.ub <= 0) {
      return MAInterval.empty()
    } else if (a.lb <= 0) {
      // In JavaScript, Math.log is base e (aka ln)
      return new MAInterval(Number.NEGATIVE_INFINITY, Math.log(a.ub))
    } else {
      return new MAInterval(Math.log(a.lb), Math.log(a.ub))
    }
  },


  // a - interval or number
  log: function(a) {
    return this.times(this.ln(a), this.recip(this.ln(10)))
  },


  // a - interval or number
  // i - integer >= 0
  powToInteger: function(a, i) {
    a = this.toInterval(a)

    if (a.isEmpty) {
      return MAInterval.empty()
    }

    let lbAbs = Math.abs(a.lb)
    let ubAbs = Math.abs(a.ub)
    let tmax = Math.max(lbAbs, ubAbs)

    // Power is a multiple of 2
    if (i > 0 && i % 2 == 0) {
      if ((a.lb < 0) != (a.ub < 0)) {
        return new MAInterval(0, tmax**i)
      } else {
        let tmin = Math.min(lbAbs, ubAbs)
        return new MAInterval(tmin**i, tmax**i)
      }
    } else {
      return new MAInterval(a.lb**i, a.ub**i)
    }
  },


  // a - interval or number
  // b - interval or number
  // Raise a to the power b
  pow: function(a, b) {
    a = this.toInterval(a)
    b = this.toInterval(b)

    if (a.isEmpty || b.isEmpty) {
      return MAInterval.empty()
    }

    // Check if the power is a single value (rather than an interval).
    // Use floatNear rather than floatEquals to check whether
    // the power is a constant and/or integer. Using a less-precise
    // check lets us converge to a constant power (rather than using
    // a very narrow interval as power). We need to converge to a
    // constant power to get correct results near power=0.
    // Graphing the formula y=x^x shows glitches for x=0 because we do not
    // rule out intervals that truly do not contain solutions for the formula.
    if (MAFloatMath.floatNear(b.lb, b.ub)) {
      let power = b.lb

      // power is effectively an integer
      if (MAFloatMath.floatNear(power - Math.round(power), 0)) {
        power = Math.round(power)

        if (power >= 0) {
          return this.powToInteger(a, power)
        } else {
          return this.recip(this.powToInteger(a, -power))
        }
      }
    }

    return this.exp(this.times(b, this.ln(a)))
  },


  // a - interval or number
  sqrt: function(a) {
    a = this.toInterval(a)

    if (a.isEmpty) {
      return MAInterval.empty()
    }

    if (a.lb >= 0) {
      return new MAInterval(Math.sqrt(a.lb), Math.sqrt(a.ub))
    } else if (a.ub < 0) {
      return MAInterval.empty()
    } else {
      return new MAInterval(0, Math.sqrt(a.ub))
    }
  },


  // a - interval or number
  recip: function(a) {
    a = this.toInterval(a)

    if (a.isEmpty) {
      return MAInterval.empty()
    }

    // If the interval is small and contains zero,
    // return empty indicating undefined. Doing this resolves glitches seen
    // in graphs of y=x/x, y=3*sin(x)/x
    let threshold = 1e-3
    if (a.ub-a.lb < threshold && Math.abs(a.ub) < threshold) {
      return MAInterval.empty()
    }

    if (Math.sign(a.lb) == 0 && Math.sign(a.ub) == 0) {
      return MAInterval.empty()
    } else if (a.lb > 0 || a.ub < 0) {
      return new MAInterval(1.0/a.ub, 1.0/a.lb)
    } else if (a.lb >= 0 && a.ub > 0) {
      return new MAInterval(1.0/a.ub, Number.POSITIVE_INFINITY)
    } else if (a.lb < 0 && a.ub <= 0) {
      return new MAInterval(Number.NEGATIVE_INFINITY, 1.0/a.lb)
    } else {
      // The interval contains zero
      return new MAInterval(Number.NEGATIVE_INFINITY, Number.POSITIVE_INFINITY)
    }
  },


  // a - interval or number
  cos: function(a) {
    a = this.toInterval(a)

    if (a.isEmpty) {
      return MAInterval.empty()
    }

    // cos(a) = 1 at a = 2*n*pi
    // cos(a) = -1 at a = (2*n+1)*pi

    let cosmin = Math.PI * Number.MIN_SAFE_INTEGER
    let cosmax = Math.PI * Number.MAX_SAFE_INTEGER

    let c0 = a.lb > Number.NEGATIVE_INFINITY ? Math.cos(a.lb) : -1
    let c1 = a.ub < Number.POSITIVE_INFINITY ? Math.cos(a.ub) : 1

    let n0 = a.lb > cosmin ? Math.floor(a.lb/Math.PI) : Number.MIN_SAFE_INTEGER
    let n1 = a.ub < cosmax ? Math.floor(a.ub/Math.PI) : Number.MAX_SAFE_INTEGER

    // no min/max crossing
    if (n0 == n1) {
      return new MAInterval(Math.min(c0, c1), Math.max(c0, c1))
    } else if (n1 > n0+1) { // cross 1 and -1
      return new MAInterval(-1, 1)
    } else { // n1 == n0 + 1
      if (n0 % 2 == 0) {
        return new MAInterval(-1, Math.max(c0, c1))
      } else {
        return new MAInterval(Math.min(c0, c1), 1)
      }
    }
  },


  // a - interval or number
  sin: function(a) {
    return this.cos(this.plus(a, -Math.PI/2))
  },


  // a - interval or number
  tan: function(a) {
    return this.times(this.sin(a), this.recip(this.cos(a)))
  },


  // a - interval or number
  asin: function(a) {
    a = this.toInterval(a)

    if (a.isEmpty) {
      return MAInterval.empty()
    }

    if (a.lb <= 1 && a.ub >= -1) {
      return new MAInterval(Math.asin(Math.max(a.lb, -1)), Math.asin(Math.min(a.ub, 1)))
    } else {
      return MAInterval.empty()
    }
  },


  // a - interval or number
  acos: function(a) {
    return this.neg(this.plus(this.asin(a), -Math.PI/2))
  },


  // a - interval or number
  atan: function(a) {
    a = this.toInterval(a)

    if (a.isEmpty) {
      return MAInterval.empty()
    }

    return new MAInterval(Math.atan(a.lb), Math.atan(a.ub))
  },


  // x - interval or number
  // y - interval or number
  rFunc: function(x, y) {
    return MAIntervalMath.sqrt(MAIntervalMath.plus(MAIntervalMath.pow(x,2), MAIntervalMath.pow(y,2)))
  },


  // x - interval or number
  // y - interval or number
  negRFunc: function(x, y) {
    return MAIntervalMath.neg(MAIntervalMath.rFunc(x, y))
  },


  // i - integer >= 0
  // offset - number (usually 0 or PI)
  // Returns a function that is used as theta when evaluating formulas
  // i and offset lets us evaluate theta in different ranges
  // The returned function's values range from [2*i*PI to 2*i*PI+2*PI]
  // For i=0, offset=0, the returned function's values range from [0 to 2*PI]
  thetaFunc: function(i, offset) {
    return function(y, x) {
      // We want these ranges to be the same and that's why we use atan2 (result range [-pi, pi])
      // when offset is pi and theta (result range [0, 2pi]) when offset is 0
      //
      // When offset is 0, result range is [2*i*PI, 2*i*PI + 2*PI]
      // When offset is PI, result range is [2*i*PI + -PI + PI, 2*i*PI + PI + PI]
      //
      // We want these ranges to be the same because offset=PI is how we graph negative r values.
      // We need to draw negative r values in the same range of theta that we draw positive r values.
      if (offset == Math.PI) {
        return MAIntervalMath.plus(MAIntervalMath.atan2(y, x), 2*i*Math.PI+offset)
      } else {
        return MAIntervalMath.plus(MAIntervalMath.theta(y, x), 2*i*Math.PI+offset)
      }
    }
  },


  // y - interval or number
  // x - interval or number
  // Returns the angle in radians range: [0, 2pi] from the positive x-axis to the point (x, y)
  theta: function(y, x) {
    // atan2 gives a result in [-pi, pi]
    // To get a result in [0, 2pi], I'm using a trick from
    // https://stackoverflow.com/questions/1311049/how-to-map-atan2-to-degrees-0-360
    // Negating x and y puts us in the opposite quadrant and adding PI rotates us back
    // to the correct quadrant.
    let atanRes = this.plus(this.atan2(this.neg(y), this.neg(x)), Math.PI)
    return atanRes
  },


  // y - interval or number
  // x - interval or number
  atan2: function(y, x) {
    y = this.toInterval(y)
    x = this.toInterval(x)

    if (y.isEmpty || x.isEmpty) {
      return MAInterval.empty()
    }

    if (x.lb <= 0 && x.ub > 0 && y.lb < 0 && y.ub > 0) {
      return new MAInterval(-Math.PI, Math.PI)
    }

    // atan2 is discontinuous across the negative x-axis with a result near pi above the axis
    // and a result near -pi below the axis. To avoid rendering glitches caused by getting intervals
    // that are way too wide, return the full range of atan2 (-pi to pi) until we have gotten
    // close enough to y=0 that we can simply return -pi
    // Rendering glitches could be seen in the graph of r=theta by zooming out and panning.
    if (x.ub < 0) {
      if (MAFloatMath.floatNear(y.lb, 0) && MAFloatMath.floatNear(y.ub, 0)) {
        return new MAInterval(-Math.PI, -Math.PI)
      } else if (y.lb < 0 && y.ub > 0) {
        return new MAInterval(-Math.PI, Math.PI)
      }
    }

    let r1 = Math.atan2(y.lb, x.lb)
    let r2 = Math.atan2(y.lb, x.ub)
    let r3 = Math.atan2(y.ub, x.lb)
    let r4 = Math.atan2(y.ub, x.ub)

    let minR = Math.min(r1, Math.min(r2, Math.min(r3, r4)))
    let maxR = Math.max(r1, Math.max(r2, Math.max(r3, r4)))

    return new MAInterval(minR, maxR)
  },


  // a - interval or number
  // Returns a pseudorandom value between 0 and 1
  // The pseudorandom value is determined by the integer part of the input
  // e.g. 1.1, 1.2, 1.3, ..., 1.9, 1.99 all have the same cellnoise value
  // Based on the implementation in graphtoy.js
  cellnoise: function(a) {
    a = this.toInterval(a)

    if (a.isEmpty) {
      return MAInterval.empty()
    }

    let threshold = 1e-3

    let n = null
    if (MAFloatMath.floatEquals(Math.floor(a.lb), Math.floor(a.ub))) {
      n = Math.floor(a.lb)
    } else if (a.ub-a.lb < threshold) {
      n = Math.floor(a.ub)
    }

    if (n !== null) {
      n = n | 0 // Force n to be an integer
      n = (n << 13) ^ n;
      n = (n * (n * n * 15731 + 789221) + 1376312589);
      n = (n>>14) & 65535;
      let res = n/65535.0;
      return new MAInterval(res, res)
    }

    return new MAInterval(0, 1)
  },


  // a - interval or number
  // Returns a pseudorandom smoothed value between -1 and 1
  // Based on the implementation in graphtoy.js
  noise: function(a) {
    a = this.toInterval(a)

    if (a.isEmpty) {
      return MAInterval.empty()
    }

    // Performance optimization: rendering is 2x sped up
    // by short-circuiting and using a coarser result for wide intervals
    if (a.ub-a.lb > 0.5) {
      return new MAInterval(-1, 1)
    }

    let i = this.floor(a)
    let f = this.plus(a, this.neg(i))
    let w = this.times(f, this.times(f, this.times(f, this.plus(this.times(f, this.plus(this.times(f, 6), -15)), 10))))
    let c = this.times(this.plus(this.times(2, this.cellnoise(i)), -1), f)
    let b = this.times(this.plus(this.times(2, this.cellnoise(this.plus(i, 1))), -1), this.plus(f, -1))

    let res = this.times(2, this.plus(c, this.times(this.plus(b, this.neg(c)), w)))

    return res
  },


  // a - interval or number
  // Returns a pseudorandom triangular value from 0 to 1
  // Based on the implementation in graphtoy.js
  voronoi: function(a) {
    a = this.toInterval(a)

    if (a.isEmpty) {
      return MAInterval.empty()
    }

    let i = this.floor(a)
    let f = this.plus(a, this.neg(i))

    let x0 = this.cellnoise(this.plus(i, -1))
    let x1 = this.cellnoise(i)
    let x2 = this.cellnoise(this.plus(i, 1))

    let d0 = this.abs(this.plus(f, this.neg(this.plus(-1, x0))))
    let d1 = this.abs(this.plus(f, this.neg(x1)))
    let d2 = this.abs(this.plus(f, this.neg(this.plus(1, x2))))

    let r = d0
    r = this.min(d1, r)
    r = this.min(d2, r)
    return r
  },


  // x - interval or number
  // lb - interval or number, lower bound
  // ub - interval or number, upper bound
  clamp: function(x, lb, ub) {
    return this.min(this.max(x, lb), ub)
  },


  // x - interval or number
  saturate: function(x) {
    return this.clamp(x, 0, 1)
  },


  // a - interval or number
  // b - interval or number
  // x - interval or number
  // Returns a result between 0 and 1
  // Result is the portion of the smooth step from a (lower-bound) to b (upper-bound) for the interval x
  // Graph y=smoothstep(-2, 5, x) to see an example
  // Based on the implementation in graphtoy.js
  smoothstep: function(a, b, x) {
    let num = this.plus(x, this.neg(a))
    let denom = this.plus(b, this.neg(a))
    let i = this.times(num, this.recip(denom))
    let y = this.saturate(i)

    let res = this.times(y, this.times(y, this.plus(3, this.neg(this.times(2, y)))))
    return res
  },


  // a - interval or number
  ltz: function(a) {
    a = this.toInterval(a)

    if (a.isEmpty) {
      return MAInterval.empty()
    }

    let lb = 0
    let ub = 0

    if (a.lb <= 0 && a.ub <= 0) {
      lb = 0
      ub = 0
    } else if (a.lb <= 0) {
      lb = 0
      ub = a.ub
    } else {
      lb = a.lb
      ub = a.ub
    }

    return new MAInterval(lb, ub)
  },

  containsZero: function(a) {
    a = this.toInterval(a)

    if (a.isEmpty) {
      return false
    }

    return a.lb <= 0 && a.ub >= 0
  },

  equalsNumber: function(i, n) {
    i = this.toInterval(i)

    if (i.isEmpty) {
      return false
    }

    return MAFloatMath.floatEquals(i.lb, n) && MAFloatMath.floatEquals(i.ub, n)
  },

  isFinite: function(i) {
    i = this.toInterval(i)

    if (i.isEmpty) {
      return false
    }

    return Number.isFinite(i.lb) && Number.isFinite(i.ub)
  },

  // Constants used by checkZeros
  MayContainZero: 0,
  MustContainZero: 1,
  IsFinite: 2,

  // Inputs:
  // - formulaFn - JavaScript function for the mathematical formula being graphed. Function of (x,y,t)
  // - x - number or MAInterval to pass into formulaFn
  // - y - number or MAInterval to pass into formulaFn
  // - t - number to pass into formulaFn
  // - mathContext - MAMathContext instance
  // Returns an array result such that:
  // result[MAIntervalMath.MayContainZero] = boolean
  // result[MAIntervalMath.MustContainZero] = boolean
  // result[MAIntervalMath.IsFinite] = boolean
  checkZeros: function(formulaFn, x, y, t, mathContext) {
    if (formulaFn == null) {
      throw "formulaFn is null\n" + (new Error()).stack
    }

    let formulaResult = formulaFn(x, y, t, mathContext)

    let mayContainZero = this.containsZero(formulaResult)
    let mustContainZero = this.equalsNumber(formulaResult, 0.0)
    let isFinite = this.isFinite(formulaResult)

    return [mayContainZero, mustContainZero, isFinite]
  },
}
Object.freeze(MAIntervalMath)


const MARelplot = {
  // Matching relplot.sml behavior
  // More information about negative zero: https://medium.com/coding-at-dawn/is-negative-zero-0-a-number-in-javascript-c62739f80114
  // Dividing a positive number by negative zero yields -Infinity
  left: function(n) {
    if (n == 0.0) {
      return -0.0
    } else {
      return n
    }
  },


  // Find a single zero along the line (x1, y1) - (x2, y2)
  // Inputs:
  // - formulaFn - JavaScript function for the mathematical formula being graphed
  // - x1, y1, x2, y2 - numbers
  // - t - number to pass into formulaFn
  // - mathContext - MAMathContext instance
  // Returns null or an MAPoint
  findZero: function(formulaFn, x1, y1, x2, y2, t, mathContext) {

    let xInterval = new MAInterval(x1, x2)
    let yInterval = new MAInterval(y1, y2)
    let checkZerosRes = MAIntervalMath.checkZeros(formulaFn, xInterval, yInterval, t, mathContext)

    let mayContainZero = checkZerosRes[MAIntervalMath.MayContainZero]
    let isFinite = checkZerosRes[MAIntervalMath.IsFinite]

    if (mayContainZero) {
      let p1 = new MAPoint(x1, y1)
      let p2 = new MAPoint(x2, y2)

      let xMid = (x1 + x2)/2.0
      let yMid = (y1 + y2)/2.0


      let pMid = new MAPoint(xMid, yMid)

      if (pMid.isEqual(p1) || pMid.isEqual(p2)) {
        if (isFinite) {
          return pMid // close enough!
        } else {
          return null // looks like divergence
        }
      } else {
        let result = this.findZero(formulaFn, x1, y1, xMid, yMid, t, mathContext)
        if (result) {
          return result
        } else {
          return this.findZero(formulaFn, xMid, yMid, x2, y2, t, mathContext)
        }
      }
    } else {
      return null
    }
  },


  // Inputs:
  // - formulaFn - JavaScript function for the mathematical formula being graphed
  // - xInterval - range of x values to evaluate, a tiny interval
  // - yInterval - range of y values to evaluate
  // - t - number to pass into formulaFn
  // - mathContext - MAMathContext instance
  // - renderedItems - array of MALineSegment and MABox instances. This method appends to this list.
  // Note: The equivalent method in relplot.sml is fine_test
  appendRenderedItemsForTinyInterval: function(formulaFn, xInterval, yInterval, t, mathContext, renderedItems) {
    let i0 = this.findZero(formulaFn, xInterval.lb, yInterval.lb, xInterval.lb, yInterval.ub, t, mathContext)
    let i1 = this.findZero(formulaFn, xInterval.ub, yInterval.lb, xInterval.ub, yInterval.ub, t, mathContext)
    let i2 = this.findZero(formulaFn, xInterval.lb, yInterval.lb, xInterval.ub, yInterval.lb, t, mathContext)
    let i3 = this.findZero(formulaFn, xInterval.lb, yInterval.ub, xInterval.ub, yInterval.ub, t, mathContext)

    let uniqueZeros = []

    if (i0 != null) {
      uniqueZeros.push(i0)
    }

    if ((i1 != null) && (uniqueZeros.filter(x => i1.isNear(x)).length == 0)) {
      uniqueZeros.push(i1)
    }

    if ((i2 != null) && (uniqueZeros.filter(x => i2.isNear(x)).length == 0)) {
      uniqueZeros.push(i2)
    }

    if ((i3 != null) && (uniqueZeros.filter(x => i3.isNear(x)).length == 0)) {
      uniqueZeros.push(i3)
    }


    if (uniqueZeros.length == 1) {
      // Nothing to add

    } else if (uniqueZeros.length == 2) {
      let p0 = uniqueZeros[0]
      let p1 = uniqueZeros[1]
      renderedItems.push(new MALineSegment(p0, p1))

    } else if (uniqueZeros.length == 3) {
      let p0 = uniqueZeros[0]
      let p1 = uniqueZeros[1]
      let p2 = uniqueZeros[2]
      renderedItems.push(new MALineSegment(p0, p1))
      renderedItems.push(new MALineSegment(p0, p2))
      renderedItems.push(new MALineSegment(p1, p2))

    } else if (uniqueZeros.length == 4) {
      let p0 = uniqueZeros[0]
      let p1 = uniqueZeros[1]
      let p2 = uniqueZeros[2]
      let p3 = uniqueZeros[3]
      renderedItems.push(new MALineSegment(p0, p1))
      renderedItems.push(new MALineSegment(p0, p2))
      renderedItems.push(new MALineSegment(p1, p2))
      renderedItems.push(new MALineSegment(p0, p3))
      renderedItems.push(new MALineSegment(p1, p3))
      renderedItems.push(new MALineSegment(p2, p3))

    } else { // 0
      // This interval _might_ contain a zero but the edges
      // of this region have no zeros.
      //
      // To represent the possibility of a zero, we could add an MABox like this:
      //let corner1 = new MAPoint(xInterval.lb, yInterval.lb)
      //let corner2 = new MAPoint(xInterval.ub, yInterval.ub)
      //renderedItems.push(new MABox(corner1, corner2))
      //
      // But it turns out that is almost never what we want.
      // If we draw this box, we will end up graphing a lot of regions
      // which might have a zero but which truly do not.
    }
  },


  // Inputs:
  // - formulaFn - JavaScript function for the mathematical formula being graphed
  // - xInterval - range of x values to evaluate
  // - yInterval - range of y values to evaluate
  //    - xInterval and yInterval together represent the rectangle of the grid we are graphing in
  // - t - number to pass into formulaFn
  // - resolution - float; the smallest size of interval to evaluate
  // - renderedItems - array of MALineSegment and MABox instances. This method appends to this list.
  render: function(formulaFn, xInterval, yInterval, t, resolution, renderedItems) {
    //console.log(`render: xInterval:[${xInterval.lb}, ${xInterval.ub}] yInterval:[${yInterval.lb}, ${yInterval.ub}] resolution:${resolution}`)

    //console.log(`Rendering ${formulaFn.toString()}`)
    let startMillis = performance.now()

    if (MAUtils.formulaFnUsesTheta(formulaFn)) {

      for (let i = 0; i < 10; ++i) {
        let mc = new MAMathContext()
        mc.thetaFn = MAIntervalMath.thetaFunc(i, 0)
        mc.rFn = MAIntervalMath.rFunc

        this._render(formulaFn, xInterval, yInterval, t, mc, resolution, renderedItems)

        if (renderedItems.length > MAUtils.maxRenderLength) {
          break
        }

        if (MAUtils.formulaFnUsesR(formulaFn)) {
          // Translate the negative r values (that would be missed) into positive ones
          mc.rFn = MAIntervalMath.negRFunc
          mc.thetaFn = MAIntervalMath.thetaFunc(i, Math.PI)
          this._render(formulaFn, xInterval, yInterval, t, mc, resolution, renderedItems)
        }

        if (renderedItems.length > MAUtils.maxRenderLength) {
          break
        }

        // Restitching is skipped because it significantly slows down rendering
      }


    } else { // Formula does not use theta

      let mc = new MAMathContext()
      this._render(formulaFn, xInterval, yInterval, t, mc, resolution, renderedItems)

      if (renderedItems.length > MAUtils.maxRenderLength) {
        console.log("Returning empty rendering results rather than incomplete results")
        renderedItems.length = 0

      } else {
        let restitchedItems = this.restitch(renderedItems)
        renderedItems.length = 0
        Array.prototype.push.apply(renderedItems, restitchedItems)
      }
    }

    let endMillis = performance.now()
    let elapsedMillis = endMillis-startMillis
    console.log("Rendering took " + (elapsedMillis/1000) + "s")
  },

  _render: function(formulaFn, xInterval, yInterval, t, mathContext, resolution, renderedItems) {
    // Callers need to pass in an array since the result of this method is appended there
    if (renderedItems == null) {
      console.log("render: renderedItems list is null. returning early")
      return
    }

    if (renderedItems.length > MAUtils.maxRenderLength) {
      console.log("Rendering too many items, giving up")
      return
    }

    let checkZerosRes = MAIntervalMath.checkZeros(formulaFn, xInterval, yInterval, t, mathContext)

    let mayContainZero = checkZerosRes[MAIntervalMath.MayContainZero]
    let mustContainZero = checkZerosRes[MAIntervalMath.MustContainZero]
    let isFinite = checkZerosRes[MAIntervalMath.IsFinite]

    if (mustContainZero) {
      let corner1 = new MAPoint(xInterval.lb, yInterval.lb)
      let corner2 = new MAPoint(xInterval.ub, yInterval.ub)
      renderedItems.push(new MABox(corner1, corner2))

    } else if (mayContainZero) {

      let tinyInterval = (xInterval.ub - xInterval.lb) <= resolution
      if (tinyInterval) {
        this.appendRenderedItemsForTinyInterval(formulaFn, xInterval, yInterval, t, mathContext, renderedItems)

      } else {

        // Split up the search space and recursively search for more zeros
        let xMid = (xInterval.lb + xInterval.ub)/2.0
        let yMid = (yInterval.lb + yInterval.ub)/2.0

        // Quadrant 1
        this._render(formulaFn,
          new MAInterval(xInterval.lb, this.left(xMid)),
          new MAInterval(yInterval.lb, this.left(yMid)),
          t, mathContext, resolution, renderedItems)

        // Quadrant 2
        this._render(formulaFn,
          new MAInterval(xInterval.lb, this.left(xMid)),
          new MAInterval(yMid, yInterval.ub),
          t, mathContext, resolution, renderedItems)

        // Quadrant 3
        this._render(formulaFn,
          new MAInterval(xMid, xInterval.ub),
          new MAInterval(yMid, yInterval.ub),
          t, mathContext, resolution, renderedItems)

        // Quadrant 4
        this._render(formulaFn,
          new MAInterval(xMid, xInterval.ub),
          new MAInterval(yInterval.lb, this.left(yMid)),
          t, mathContext, resolution, renderedItems)
      }
    }
  },


  restitch: function(renderedItems) {
    //console.log(`restitch began with ${renderedItems.length} items`)

    let result = []
    let lines = []

    let count = renderedItems.length
    for (let i = 0; i < count; ++i) {
      if (renderedItems[i] instanceof MALineSegment) {
        lines.push(renderedItems[i])
      } else {
        // Don't try to restitch boxes
        result.push(renderedItems[i])
      }
    }

    // For each line segment: try to combine it with one of the later line segments.
    // If I can, smush them together. If I can't, add it to result.
    count = lines.length
    for (let i = 0; i < count; ++i) {
      let line = lines[i]

      let foundMatch = false
      for (let j = i+1; j < count; ++j) {
        let potentialMatch = lines[j]
        if (potentialMatch.combineWith(line)) {
          foundMatch = true
          break
        }
      }

      if (!foundMatch) {
        result.push(line)
      }
    }

    //console.log(`restitch finished with ${result.length} items`)

    return result
  },
}
Object.freeze(MARelplot)

